#플러터 #모바일개발
1
다트 소개

구글이 개발한 다트 프로그래밍 언어Dart programming language는 
2011년 10월 GOTO 콘퍼런스에서 공개

- 처음에는 웹, 응용, 모바일 전부다 통합 할 목적이었지만, 
- 웹은 여론에 막혀서, 일단은, 
- 자바스크립트로 완전 컴파일 가능

2
다트의 장점

- UI(User Interace)를 제작하는데 최적화
- 완전한 비동기 언어
- 이벤트 기반
- 이솔레이트ISolate를 이용한 동시성 기능

이솔레이트란?
독립적인 메모리 공간과 이벤트 루프를 가진 실행 단위

왜 사용하죠?
UI 앱에서 백그라운드 작업(예: 파일 처리, 네트워크 요청 등)을 하면
UI가 멈추는 문제가 발생

결론, 화면단과, 백단으로 분리해서 작업을 한다. 


2)
널 안정성 null Safety, 스프레드 기능 Spead Operator, 
컬렉션 if문 Collection If 등 효율적으로 UI 작업가능. 

3)
핫 리로드를 통해 코드의 변경 사항을 즉시 화면에 반영

4) 
AOT(사전 컴파일) 컴파일이 가능하기 때문에 어떤 플랫폼에서든 
빠른 속도
JIT(동적 으로 컴파일)

5) 
자바스크립트로의 완전한 컴파일을 지원



2
문법 공부 환경 안내

다트패드에서 문법 공부하기
https://dartpad.dev

3
안드로이드 스튜디오에서 문법 공부하기

lib/main.dart

void main() {
print('hello world');
}

4

1)
프로그램 시작점인 엔트리 함수 기호로 main()을 사용

void main() {

｝

2)
주석
프로그램에서 코드로 인식하지 
않는 부분

void main() {
// 주석을 작성하는 첫 번째 방법은
// 한 줄 주석입니다.
/*
  *여러 줄 주석 방법입니다.
  *시작 기호는 /*이고 끝나는 기호는 */입니다.
  *필수는 아니지만 관행상 중간 줄의 시작으로 *를 사용합니다.
  */
/// 슬래시 세 개를 사용하면 
/// 문서 주석을 작성할 수 있습니다.
/// DartDoc이나 안드로이드 스튜디오 같은 
/// IDE에서 문서(Documentation)로 인식합니다.

}

3)
print() 함수
print() 함수는 문자열을 콘솔에 출력

void main(){
// 콘솔에 출력
print('Hello World');
}

4)
var를 사용한 변수 선언
변수에 값이 들어가면 자동으로 타입을 추론

void main(){
var name = '부산it501';
print(name);

// 변숫값 변경 가능
name = '부산it501-test';
print(name);

// 변수명 중복은 불가능
// 그래서 다음 코드에서 주석을 제거하면 코드에서 에러 발생
// var name = '김고은';
}

5)
dynamic을 사용한 변수 선언

var 타입은 
변수의 값을 사용해서 변수의 타입을 유추
같은 변수에 다시 저장하려 하면 에러 발상. 

하지만, 
변수의 타입이 고정되지 
않아서 다른 타입의 값을 저장 가능. 

예)
void main() {
dynamic name = '부산it501';
name = 1;

 var name2 = '이상용'; // var 다른 타입으로 재할당 불가.
  name2 = 100; // 컴파일러 에러가 발생함. 
  print(name2);
}

6)final/const를 사용한 변수 선언 -> 상수

공통점:
변수의 값을 처음 선언 후 
변경할 수 없습니다.

차이점:
final은 런타임, const는 빌드 타임 

예시)
DateTime.now() 함수: 
실행되는 순간의 날짜 및 시간을 제공
-> 실행을 해봐야 알수 있는 함수. 

//final
void main() {
final DateTime now = DateTime.now();
print (now);
}
//const
void main() {
// 에러
const DateTime now = DateTime. now();
print (now);
}

7)
변수 타입

문자열, 정수, 실수, 불리언(true/false) 타입

void main(){
// String - 문자열
String name ='부산it501';

// int - 정수
int isInt = 10;

// double - 실수
double isDouble = 2.5;

// bool - 불리언 (true/false)
bool isTrue = true;

print(name);
print(isInt);
print(isDouble);
print(isTrue);
}


8)
컬렉션
순서대로 저장하거나 (List)
키값을 기반으로 빠르게 값을 검색(Map)
중복된 데이터를 제거 (Set)

컬렉션 타입은 
서로의 타입으로 자유롭게 형변환이 가능


9)
List 타입
여러 값을 순서대로 나열한 
변수에 저장
void main() {
	List<String> busanit501 = ['상용','수종','성엽','도현'];
	print(busanit501[0]);
	print(busanit501[3]);
	busanit501[0] = '상용2';
	busanit501.add('효정');
	print(busanit501);
}


10)
where() 함수
List에 있는 값들을 순서대로 
순회 하면서, 조건에 맞는 값만 검색한다. 

예시)
void main() {
	List<String> busanit501 = ['상용','수종','성엽','도현'];
	final newMember = busanit501.where(
		(name) => name == '상용' || name == '수종'
	);
	print(newMember);
}


11)
map() 함수
List에 있는 모든 값들을 순서대로 순회하면서 
값을 변경 가능. 

예시)
void main() {
	List<String> busanit501 = ['상용','수종','성엽','도현'];
	final newMember = busanit501.map(
		(name) => '부산it501 멤버 : $name'
	);
	print(newMember);
	print(newMember.toList());
}


12)
reduce() 함수
List에 있는 값들을 순회하면서 
매개변수에 입력된 함수를 실행
(주의, 순회 할 때마다 값을 누적해 간다.)

예시)
void main() {
  List<String> busanit501 = ['상용', '수종', '성엽', '도현'];
  final newMember = busanit501.reduce(
    (value, element) => value + ', ' + element,
  );
  print(newMember);
}


13
fold() 함수
reduce() 함수와 실행되는 논리 비슷함. 
차이점, 
reduce() 함수 : 같은 타입만 가능. 
fold() 함수 어떠한 타입이든 반환 가능. 

예시)
void main() {
  List<String> busanit501 = ['상용', '수종', '성엽', '도현'];
  final newMember = busanit501.fold<int>(
    0,(value, element) => value + element.length);
  print(newMember);
}

14
Map 타입
키Key와 값valle의 짝
Map〈키 타입, 값 타입> 맵 이름 형식으로 생성

예시)
void main() {
  Map<String, String> members = {
    'lsy': '상용',
    'psj': '수종',
    'asy': '성엽',
    'kdh': '도현',
  };
  print(members);
  print(members.keys);
  print(members.values);
  print(members.entries);
}

15

Set 타입

중복을 방지하므로 유일한 값들만 존재

void main() {
  Set<String> busanit501 = {'상용', '상용', '수종', '성엽', '도현'};
  print(busanit501);
 
 }

16
enum
자동 완성이 지원되고,
선택지가 제한적일 때 사용

예시)
enum Status {
	active, wait, exit
}

void main() {
Status status = Status.active;
print(status); // Status.active
}
===================================================

17
연산자 

수치 연산자

void main() {

double number = 2;
print (number + 2); // 4 출력 
print(number - 2); // 0 출력 
print(number * 2); // 4 출력 
print(number / 2); // 1 출력. 나눈 몫 
print(number % 3); // 2 출력. 나눈 나머지

// 단항 연산도 됩니다.
number++; // 3
number--; // 2

number += 2; // 4
number -= 2; // 0
number *= 2; //4
number /= 2; // 1
｝

7 실행 결과
4.0
0.0
4.0
1.0
2.0

18
null 관련 연산자
타입 뒤에 '?'를 추가해줘야 null값이 저장 가능. 

예시)
void main() {
// 타입 뒤에 ?를 명시해서 null 값을 가질 수 있습니다.
double? number1 = 1;

// 타입 뒤에 ?를 명시하지 않아 에러가 납니다.
double number2 = null;

타입 뒤에 ?를 추가해주면 null값이 저장될 수 있습니다. 

null을 가질 수 있는 변수에 새로운 값을 추가할 때 ??를 사용하면 

기존에 null인 때만 값이 저장되도록 할 수도 있습니다.

void main() {
double? number; // 자동으로 null값 지정 
print (number ); // null

number ??=3; // ??를 사용하면 기존 값이 nul1일 때만 저장됩니다.
print (number); // 3

number ??= 4; // null이 아니므로 30 유지됩니다.
print(number); //3
}

19
비교 연산자
void main() {
int number1 = 1;
int number2 = 2;

print(number1 › number2); // false 
print(number1 ‹ number2); // true 
print(number1 >= number2); // false 
print(number1 <= number2); // true 
print(number1 == number2); // false 
print(number1 != number2); // true
}

20
타입 비교 연산자

is 키워드를 사용하면 변수의 타입을 비교할 수 있습니다.
void main() {
int number1 = 1;
print(number1 is int); // true
print(number1 is String); // false
print(number1 is! int); // false.!는 반대를 의미합니다(int 타입이 아닌 경우 true).
print(number1 is! String);// true
}

21
논리 연산자

and와 or을 의미하는 연산자도 사용해봅시다.


void main() {
// 12가 10보다 크고 1이 0보다 클때
bool result = 12> 10 && 1> 0; 
print(result); // true

// 12가 10보다 크고 0이 1보다 클 때
bool result2 = 12> 10 && 0> 1; 
print(result2); // false

// 12가 10보다 크거나 10 0보다 클 때
bool result3 = 12> 10 || 1 > 0; 
print(result3); // true

// 12가 10보다 크거나 0이 1보다 클 때 
bool result4 = 12> 10 || 0 > 1; 
print(result4); // true

// 12가 10보다 작거나 00 1보다 클 때 
boolL result5 = 12 < 10 || 0> 1;
print(result5); // false
}

22
if문
if문은 원하는 조건을 기준으로 다른 코드를 실행하고 싶을 때 사용됩니다.
if문, else if문, else 문의 순서대로 괄호 안에 
작성한 조건이 true이면 해당 조건의 코드 블록이 실행이 됩니다.

void main() {
int number = 2;

if (number % 3 = 0) {
print('3의 배수입니다. ');
} else if (number % 3 == 1) {
print('나머지가 1입니다.');
} else {
// 조건에 맞지 않기 때문에 다음 코드 실행
print('맞는 조건이 없습니다.');
}

23

switch 문

입력된 상수값에 따라 알맞은 case 블록을 수행합니다. 
break 키워드를 사용하면 
switch문 밖으로 나갈 수 있습니다. 
case 끝에 break 키워드를 사용하는 걸 잊지 마세요
(빼먹으면 컴파일 중 에 에러가 납니다). 

enum과 함께 사용하면 유용합니다.

enum Status {
  approved,
  pending,
  rejected,
}

void main() {
  Status status = Status.approved;

  switch (status) {
    case Status.approved:
// approved값이기 때문에 다음 코드가 실행됩니다.
      print('승인 상태입니다.');
      break;

    case Status.pending:
      print('대기 상태입니다.');
      break;

    case Status.rejected:
      print('거절 상태입니다.');
      break;

    default:
      print('알 수 없는 상태입니다.');
  }
  
  print(Status.values);
}

24
for문

for문은 작업을 여러 번 반복해서 실행할 때 사용합니다.

void main() {
// 값 선언; 조건 설정; loop 마다 실행할 기능
for (int i= 0; i < 3; i++) {
print(i);
}
}

25
for...in 패턴의 for문도 제공
void main() {
List<int> numberList = [3, 6, 9];
for (int number in numberList) {
print (number);
}
}

26

while문과 do..while 문

while문과 do..while문은 for문과 마찬가지로 반복적인 작업을 
실행할 때 사용됩니다. 
미리 알아본 for문은 횟수 기반으로 함수를 반복적으로 실행합니다. 
예를 들어 
특정 리스트 길이나 지정한 숫자 이하의 횟수만 
반복하도록 코드를 작성합니다. 
while문은 조건을 기반으로 반복문을 실행합니다. 
조건이 true이면 계속 실행하고 false이면 멈추게 됩니다.



while문 먼저 알아보겠습니다.

void main() {
int total = 0;
while(total < 10) { // total값이 10보다 작으면 계속 실행
total += 1;
}
print(total);
}

do...while은 특수한 형태의 while문입니다. 
while문은 조건을 먼저 확인한 후 true가 반환되면 
반복문을 실행하지만 
do..while은 반복문을 실행한 후 조건을 확인합니다.

**"먼저 실행, 나중 검사"**하는 방식

void main() {
int total = 0;
do {
total += 1;
print(total);  
} while(total < 10);
print(total);
}


27
함수

int addTwoNumbers(int a, int b) {
return a + b;
}

void main() {
print (addTwoNumbers (1, 2));
}

28
순서가 고정된 매개변수 
positional parameter(포지셔널 파라미터, 
위치 매개변수라고도 합니다)와 

29 잘봐야 함. !!
이름이 있는 매개변수named parameter(네임드 파라미터, 
명명된 매개변수라고도 합니다)가 있습니다. 

키와 값 형태로 매개변수를 입력하면 되므로 
입력 순서는 중요하지 않습니다.

모양
네임드 파라미터를 지정하려면 
중괄호 {}와 required 키워드를 사용해야 합니다.


addTWoNumbers() 함수를 네임드 파라미터 방식으로 변환하겠습니다.

int addTwoNumbers(
{required int a, required int b, }
) {
return a + b;
}

void main() {
print(addTwoNumbers(a: 1, b: 2));
}

주의, 
required 키워드 의미. 

1 
매개변수가 null값이 불가능한 타입이면 기본값을 지정해주거나 
2
필수로 입력해야 한다는 의미입니다.

예시)
기본값을 갖는 포지셔널 파라미터를 지정하겠습니다.
[ ] 기호를 사용하면 됩니다.

int addTwoNumbers (int a, [int b = 2]) {
return a + b;
}
void main() {
print(addTwoNumbers(1));
}

예시3)
입력값이 하나뿐이라서 두 번째 매개변수에 
기본값 2를 적용해 계산한 결과를 반환했습니다.

이번에는 네임드 파라미터에 기본값을 적용하겠습니다. 
required 키워드를 생략해주고 
등호 다음에 원하는 기본값을 입력해주면 됩니다.

int addTwoNumbers({
required int a,
int b = 2,
}) {
return a + b;
}

void main() {
print(addTwoNumbers(a: 1));
}

예시4)
포지셔널 파라미터와 네임드 파라미터를 섞어서 사용

주의!
섞어 쓸 때는 
포지셔널 파라미터가 
네임드 파라미터보다 
반드시 먼저 위치해야 합니다.

int addTwoNumbers(
int a, {
required int b,
int c = 4,
})
{
  return a + b + c;
}
void main() {
print(addTwoNumbers(1, b: 3, c: 7));
}

30
익명 함수와 람다 함수

함수 이름이 없고 일회성으로 사용된다는 공통점

익명 함수와 람다 함수 표현 방식

익명 함수
:
(매개변수) {
함수 바디
}

람다 함수
:
(매개변수) => 단 하나의 스테이트먼트

예시)

익명 함수

void main() {
List<int> numbers = [1, 2, 3, 4, 5];

// 일반 함수로 모든 값 더하기
final allMembers = numbers.reduce(
// 익명 함수
(value, element) {
return value + element;
});
print(allMembers) ;
}


람다 함수

void main() {
List<int> numbers = [1, 2, 3, 4, 5];
// 람다 함수로 모든 값 더하기
final allMembers = numbers.reduce(
// 람다 함수
(value, element) => value + element);
print(allMembers);
}
출력값은 둘 다 15입니다.

31
typedef 와 함수
typedef 키워드는 함수의 시그니처를 정의

예시), 추상 메서드 비슷. 
typedef Operation = void Function(int X, int y);

예시2)
typedef Operation = void Function(int x, int y);

void add(int x, int y) {
print('결괏값 : ${x + y}');
}
void subtract(int x, int y) {
print('결괏값 : ${x - y}');
}
void main() {
// typedef는 일반적인 변수의 type처럼 사용 가능
Operation oper = add;

oper (1, 2);
// subtract() 함수도 Operation에 해당되는 
// 시그니처이므로 oper 변수에 저장 가능
oper = subtract;
oper(1, 2);
}

32
try...Catch

try...Catch
...catch문의 목적은 특정 코드의 실행을 시도(try)해보고 
문제가 있다면 에러를 잡으라 (catch)는 뜻

void main() {
try{
// 에러가 없을 때 실행할 로직 
final String name ='부산it501';
print (name); // 에러가 없으니 출력됨
}catch(e){
// catch는 첫 번째 매개변수에 에러 정보를 전달해줍니다.
// 에러가 있을 때 실행할 로직
print(e);
}
}

33


